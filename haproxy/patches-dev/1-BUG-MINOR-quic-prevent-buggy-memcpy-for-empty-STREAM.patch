From e91349a61ee86b911d5aea5e5a1f519b59ad1ed2 Mon Sep 17 00:00:00 2001
From: Amaury Denoyelle <adenoyelle@haproxy.com>
Date: Tue, 25 Apr 2023 15:52:24 +0200
Subject: [PATCH] BUG/MINOR: quic: prevent buggy memcpy for empty STREAM

Sometimes it may be necessary to send empty STREAM frames with only the
FIN bit set. For these frames, memcpy is thus unnecessary as their
payload is empty. However, we did not prevent its invocation inside
quic_build_stream_frame().

Normally, memcpy invocation with length==0 is safe. However, there is an
extra condition in our function to handle data wrapping. For an empty
STREAM frame in the context of MUX emission, this is safe as the frame
points to a valid buffer which causes the wrapping condition to be false
and resulting in a memcpy with 0 length.

However, in the context of retransmission, this may lead to a crash.
Consider the following scenario : two STREAM frames A and B are
produced, one with payload and one empty with FIN set, pointing to the
same stream_desc buffer. If A is acknowledged by the peer, its buffer is
released as no more data is left in it. If B needs to be resent, the
wrapping condition will be messed up to a reuse of a freed buffer. Most
of the times, <wrap> will be a negative number, which results in a
memcpy invocation causing a buffer overflow.

To fix this, simply add an extra condition to skip memcpy and wrapping
check if STREAM frame length is null inside quic_build_stream_frame().

This crash seems rare as it relies on several preconditions. It seems to
be the cause for the latest crashes reported under github issue #2120.
In all the inspected dumps, the segfault occurred during retransmission
with an empty STREAM frame being used as input.

This should be backported up to 2.7.
---
 src/quic_frame.c | 4 ++++
 1 file changed, 4 insertions(+)

diff --git a/src/quic_frame.c b/src/quic_frame.c
index 9cf5214f6..1902b8df8 100644
--- a/src/quic_frame.c
+++ b/src/quic_frame.c
@@ -520,6 +520,10 @@ static int quic_build_stream_frame(unsigned char **buf, const unsigned char *end
 	     (!quic_enc_int(buf, end, strm_frm->len) || end - *buf < strm_frm->len)))
 		return 0;

+	/* No need for data memcpy if no payload. */
+	if (!strm_frm->len)
+		return 1;
+
 	wrap = (const unsigned char *)b_wrap(strm_frm->buf);
 	if (strm_frm->data + strm_frm->len > wrap) {
 		size_t to_copy = wrap - strm_frm->data;
--
2.40.0

