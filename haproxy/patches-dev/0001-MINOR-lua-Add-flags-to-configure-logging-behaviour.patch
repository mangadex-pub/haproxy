From 2c916e36954a0aa55b53d4e3d5682fa2eac9f0c3 Mon Sep 17 00:00:00 2001
From: Tristan <tristan@mangadex.org>
Date: Thu, 19 Oct 2023 03:39:19 +0100
Subject: [PATCH] MINOR: lua: Add flags to configure logging behaviour

Until now, messages printed from LUA log functions were sent both to
the any logger configured for the current proxy, and additionally to
stderr (in most cases)

This introduces two flags to configure LUA log handling:
- tune.lua.log to use standard loggers or not
- tune.lua.log-stderr to use stderr, or not, or only conditionally

This addresses github feature request #2316

This can be backported to 2.8 as it doesn't change previous behaviour
---
 doc/configuration.txt | 20 ++++++++++++
 doc/lua.txt           |  4 +++
 src/hlua.c            | 71 +++++++++++++++++++++++++++++++++++++++++--
 3 files changed, 92 insertions(+), 3 deletions(-)

diff --git a/doc/configuration.txt b/doc/configuration.txt
index 88a576795..d620ea554 100644
--- a/doc/configuration.txt
+++ b/doc/configuration.txt
@@ -1195,6 +1195,8 @@ The following keywords are supported in the "global" section :
    - tune.lua.service-timeout
    - tune.lua.session-timeout
    - tune.lua.task-timeout
+   - tune.lua.log
+   - tune.lua.log-stderr
    - tune.max-checks-per-thread
    - tune.maxaccept
    - tune.maxpollevents
@@ -3180,6 +3182,24 @@ tune.lua.task-timeout <timeout>
   remain alive during of the lifetime of HAProxy. For example, a task used to
   check servers.
 
+tune.lua.log { on | off }
+  Enables ('on') or disables ('off') logging the output of LUA scripts via the
+  loggers applicable to the current proxy, if any.
+  
+  Defaults to 'on'.
+
+tune.lua.log-stderr { on | auto | off }
+  Enables ('on') or disables ('off') logging the output of LUA scripts via
+  stderr. When set to 'auto', logging via stderr is conditionally enabled if:
+  
+    - tune.lua.log is set to 'off', or
+    - no logger is configured for the current proxy
+  
+  Please note that, when enabled, this logging is in addition to the logging
+  configured via tune.lua.log.
+
+  Defaults to 'on'.
+
 tune.max-checks-per-thread <number>
   Sets the number of active checks per thread above which a thread will
   actively try to search a less loaded thread to run the health check, or
diff --git a/doc/lua.txt b/doc/lua.txt
index 8d5561668..5516ac36a 100644
--- a/doc/lua.txt
+++ b/doc/lua.txt
@@ -630,6 +630,10 @@ It displays a log during the HAProxy startup:
 
    [alert] 285/083533 (14465) : Hello World !
 
+Note: By default, logs originating from a LUA script are sent to the loggers
+applicable to the current proxy, if any, and additionally to stderr. See
+tune.lua.log and tune.lua.log-stderr for more.
+
 Default path and libraries
 --------------------------
 
diff --git a/src/hlua.c b/src/hlua.c
index c686f222a..c6751980c 100644
--- a/src/hlua.c
+++ b/src/hlua.c
@@ -69,6 +69,20 @@
 #include <haproxy/check.h>
 #include <haproxy/mailers.h>
 
+/* Global LUA flags */
+/* log handling */
+#define HLUA_TUNE_LOG             0x00000001 /* send to current logger */
+#define HLUA_TUNE_LOG_STDERR_ON   0x00000010 /* send to stderr */
+#define HLUA_TUNE_LOG_STDERR_AUTO 0x00000020 /* send to stderr if no logger available */
+#define HLUA_TUNE_LOG_STDERR_OFF  0x00000040 /* never send to stderr */
+#define HLUA_TUNE_LOG_STDERR_MASK 0x00000070
+
+/* default flag values */
+#define HLUA_TUNE_FLAGS_DFLT	  0x00000011
+
+/* flags made of HLUA_TUNE_* */
+static uint hlua_tune_flags = HLUA_TUNE_FLAGS_DFLT;
+
 /* Lua uses longjmp to perform yield or throwing errors. This
  * macro is used only for identifying the function that can
  * not return because a longjmp is executed.
@@ -1366,8 +1380,9 @@ const char *hlua_show_current_location(const char *pfx)
 	return NULL;
 }
 
-/* This function is used to send logs. It try to send on screen (stderr)
- * and on the default syslog server.
+/* This function is used to send logs. It tries to send them to:
+ * - the log target applicable in the current context, AND
+ * - stderr if not in quiet mode or explicitly disabled
  */
 static inline void hlua_sendlog(struct proxy *px, int level, const char *msg)
 {
@@ -1392,8 +1407,19 @@ static inline void hlua_sendlog(struct proxy *px, int level, const char *msg)
 	}
 	*p = '\0';
 
-	send_log(px, level, "%s\n", trash.area);
+  	if (hlua_tune_flags & (HLUA_TUNE_LOG))
+	  	send_log(px, level, "%s\n", trash.area);
+
 	if (!(global.mode & MODE_QUIET) || (global.mode & (MODE_VERBOSE | MODE_STARTING))) {
+	  	if (hlua_tune_flags & HLUA_TUNE_LOG_STDERR_OFF)
+	    	return;
+
+	  	if (hlua_tune_flags & HLUA_TUNE_LOG_STDERR_AUTO) {
+			/* if using standard loggers and at least one logger is configured, then AUTO => OFF */
+      		if ((hlua_tune_flags & (HLUA_TUNE_LOG)) && (!LIST_ISEMPTY(&px->loggers)))
+	      		return;
+	  	}
+
 		if (level == LOG_DEBUG && !(global.mode & MODE_DEBUG))
 			return;
 
@@ -12433,6 +12459,43 @@ static int hlua_parse_maxmem(char **args, int section_type, struct proxy *curpx,
 	return 0;
 }
 
+static int hlua_cfg_parse_log(char **args, int section_type, struct proxy *curpx,
+                          const struct proxy *defpx, const char *file, int line,
+                          char **err)
+{
+	if (too_many_args(1, args, err, NULL))
+		return -1;
+
+	if (strcmp(args[1], "on") == 0)
+		hlua_tune_flags |= HLUA_TUNE_LOG;
+	else if (strcmp(args[1], "off") == 0)
+		hlua_tune_flags &= ~HLUA_TUNE_LOG;
+	else {
+		memprintf(err, "'%s' expects either 'on' or 'off' but got '%s'.", args[0], args[1]);
+		return -1;
+	}
+	return 0;
+}
+
+static int hlua_cfg_parse_log_stderr(char **args, int section_type, struct proxy *curpx,
+                                 const struct proxy *defpx, const char *file, int line,
+                                 char **err)
+{
+	if (too_many_args(1, args, err, NULL))
+		return -1;
+
+	if (strcmp(args[1], "on") == 0)
+	  hlua_tune_flags = (hlua_tune_flags & ~HLUA_TUNE_LOG_STDERR_MASK) | HLUA_TUNE_LOG_STDERR_ON;
+	else if (strcmp(args[1], "auto") == 0)
+	  hlua_tune_flags = (hlua_tune_flags & ~HLUA_TUNE_LOG_STDERR_MASK) | HLUA_TUNE_LOG_STDERR_AUTO;
+	else if (strcmp(args[1], "off") == 0)
+		hlua_tune_flags = (hlua_tune_flags & ~HLUA_TUNE_LOG_STDERR_MASK) | HLUA_TUNE_LOG_STDERR_OFF;
+	else {
+		memprintf(err, "'%s' expects either 'on', 'auto', or 'off' but got '%s'.", args[0], args[1]);
+		return -1;
+	}
+	return 0;
+}
 
 /* This function is called by the main configuration key "lua-load". It loads and
  * execute an lua file during the parsing of the HAProxy configuration file. It is
@@ -12682,6 +12745,8 @@ static struct cfg_kw_list cfg_kws = {{ },{
 	{ CFG_GLOBAL, "tune.lua.burst-timeout",   hlua_burst_timeout },
 	{ CFG_GLOBAL, "tune.lua.forced-yield",    hlua_forced_yield },
 	{ CFG_GLOBAL, "tune.lua.maxmem",          hlua_parse_maxmem },
+	{ CFG_GLOBAL, "tune.lua.log",             hlua_cfg_parse_log },
+	{ CFG_GLOBAL, "tune.lua.log-stderr",      hlua_cfg_parse_log_stderr },
 	{ 0, NULL, NULL },
 }};
 
-- 
2.41.0

